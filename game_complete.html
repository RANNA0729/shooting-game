<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>シューティングゲーム - Boss Battle Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(45deg, #000428, #004e92);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: white;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        canvas {
            border: 2px solid #00ff00;
            background: #000011;
            box-shadow: 0 0 20px #00ff00;
        }
        
        #gameInfo {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            width: 800px;
            font-size: 18px;
            color: #00ff00;
        }
        
        #instructions {
            margin-bottom: 10px;
            color: #ffffff;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ff0000;
            text-shadow: 2px 2px 4px #000;
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="instructions">WASDで移動、SPACEで攻撃</div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="gameInfo">
            <div>スコア: <span id="score">0</span></div>
            <div>ライフ: <span id="lives">3</span></div>
            <div>ステージ: <span id="stage">1</span></div>
        </div>
        <div id="gameOverText" class="game-over">ゲームオーバー<br><small>Rキーでリスタート</small></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = 'playing';
        let score = 0;
        let lives = 3;
        let stage = 1;
        let keys = {};
        let gameTime = 0;
        let enemySpawnTimer = 0;
        let bossActive = false;
        let finalBossActive = false;

        // Game objects arrays
        let bullets = [];
        let enemies = [];
        let explosions = [];
        let particles = [];

        // Load boss images from Base64 files or use fallbacks
        const bossImages = {
            boss: null,
            finalBoss: null
        };

        async function loadBossImages() {
            try {
                // Try to load boss.png base64
                const bossResponse = await fetch('./boss_base64.txt');
                if (bossResponse.ok) {
                    const bossBase64 = await bossResponse.text();
                    const bossImg = new Image();
                    bossImg.src = `data:image/png;base64,${bossBase64.trim()}`;
                    bossImg.onload = () => {
                        bossImages.boss = bossImg;
                        console.log('✅ Boss image loaded from your boss.png file!');
                    };
                }

                // Try to load boss2.png base64  
                const boss2Response = await fetch('./boss2_base64.txt');
                if (boss2Response.ok) {
                    const boss2Base64 = await boss2Response.text();
                    const boss2Img = new Image();
                    boss2Img.src = `data:image/png;base64,${boss2Base64.trim()}`;
                    boss2Img.onload = () => {
                        bossImages.finalBoss = boss2Img;
                        console.log('✅ Final Boss image loaded from your boss2.png file!');
                    };
                }
            } catch (error) {
                console.log('⚠️ Could not load boss images, using fallback graphics');
            }
        }

        // Player class
        class Player {
            constructor() {
                this.x = canvas.width / 2 - 20;
                this.y = canvas.height - 60;
                this.width = 40;
                this.height = 40;
                this.speed = 6;
                this.color = '#00ff00';
                this.shootCooldown = 0;
            }

            update() {
                if (this.shootCooldown > 0) this.shootCooldown--;
                
                if (keys['w'] || keys['W'] || keys['ArrowUp']) {
                    this.y = Math.max(0, this.y - this.speed);
                }
                if (keys['s'] || keys['S'] || keys['ArrowDown']) {
                    this.y = Math.min(canvas.height - this.height, this.y + this.speed);
                }
                if (keys['a'] || keys['A'] || keys['ArrowLeft']) {
                    this.x = Math.max(0, this.x - this.speed);
                }
                if (keys['d'] || keys['D'] || keys['ArrowRight']) {
                    this.x = Math.min(canvas.width - this.width, this.x + this.speed);
                }
                
                if ((keys[' '] || keys['Space']) && this.shootCooldown === 0) {
                    this.shoot();
                    this.shootCooldown = 10;
                }
            }

            shoot() {
                bullets.push(new Bullet(this.x + this.width/2 - 2, this.y, 0, -10, '#00ffff', true));
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Ship details
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x + 15, this.y + 5, 10, 25);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(this.x + 18, this.y, 4, 10);
            }
        }

        // Bullet class
        class Bullet {
            constructor(x, y, vx, vy, color, friendly = false) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.width = 4;
                this.height = 8;
                this.color = color;
                this.friendly = friendly;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            isOffScreen() {
                return this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height;
            }
        }

        // Enemy class
        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.vx = Math.random() * 2 - 1;
                this.vy = Math.random() * 2 + 1;
                this.hp = 1;
                this.shootCooldown = 0;
                this.color = '#ff4444';
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                if (this.x <= 0 || this.x >= canvas.width - this.width) this.vx = -this.vx;
                
                this.shootCooldown--;
                if (this.shootCooldown <= 0 && Math.random() < 0.02) {
                    bullets.push(new Bullet(this.x + this.width/2, this.y + this.height, 0, 4, '#ff0000', false));
                    this.shootCooldown = 60;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x + 10, this.y + 10, 10, 10);
            }

            takeDamage() {
                this.hp--;
                return this.hp <= 0;
            }
        }

        // Boss class
        class Boss {
            constructor() {
                this.x = canvas.width / 2 - 60;
                this.y = 50;
                this.width = 120;
                this.height = 120;
                this.vx = 2;
                this.hp = 25;
                this.maxHp = 25;
                this.shootCooldown = 0;
            }

            update() {
                this.x += this.vx;
                if (this.x <= 0 || this.x >= canvas.width - this.width) this.vx = -this.vx;
                
                this.shootCooldown--;
                if (this.shootCooldown <= 0) {
                    // Triple shot
                    for (let i = -1; i <= 1; i++) {
                        bullets.push(new Bullet(
                            this.x + this.width/2 + i * 30, 
                            this.y + this.height, 
                            i * 2, 
                            5, 
                            '#ff6600', 
                            false
                        ));
                    }
                    this.shootCooldown = 50;
                }
            }

            draw() {
                // Try to use the actual boss image first
                if (bossImages.boss && bossImages.boss.complete) {
                    try {
                        ctx.drawImage(bossImages.boss, this.x, this.y, this.width, this.height);
                    } catch (e) {
                        this.drawFallback();
                    }
                } else {
                    this.drawFallback();
                }
                
                // Health bar
                const barWidth = this.width;
                const barHeight = 10;
                const healthPercent = this.hp / this.maxHp;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x, this.y - 20, barWidth, barHeight);
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.2 ? '#ffff00' : '#ff0000';
                ctx.fillRect(this.x, this.y - 20, barWidth * healthPercent, barHeight);
            }

            drawFallback() {
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(this.x + 20, this.y + 20, 80, 80);
                ctx.fillStyle = '#000000';
                ctx.font = '28px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('BOSS', this.x + this.width/2, this.y + this.height/2);
            }

            takeDamage() {
                this.hp--;
                return this.hp <= 0;
            }
        }

        // Final Boss class
        class FinalBoss {
            constructor() {
                this.x = canvas.width / 2 - 80;
                this.y = 30;
                this.width = 160;
                this.height = 160;
                this.vx = 1;
                this.hp = 50;
                this.maxHp = 50;
                this.shootCooldown = 0;
                this.specialAttackCooldown = 0;
            }

            update() {
                this.x += this.vx;
                if (this.x <= 0 || this.x >= canvas.width - this.width) this.vx = -this.vx;
                
                this.shootCooldown--;
                this.specialAttackCooldown--;
                
                if (this.shootCooldown <= 0) {
                    // Spread shot
                    for (let i = -2; i <= 2; i++) {
                        bullets.push(new Bullet(
                            this.x + this.width/2, 
                            this.y + this.height, 
                            i * 2, 
                            6, 
                            '#8800ff', 
                            false
                        ));
                    }
                    this.shootCooldown = 40;
                }
                
                if (this.specialAttackCooldown <= 0) {
                    // Circular attack
                    for (let i = 0; i < 12; i++) {
                        const angle = (i * Math.PI * 2) / 12;
                        bullets.push(new Bullet(
                            this.x + this.width/2, 
                            this.y + this.height/2, 
                            Math.cos(angle) * 3, 
                            Math.sin(angle) * 3, 
                            '#ff00ff', 
                            false
                        ));
                    }
                    this.specialAttackCooldown = 120;
                }
            }

            draw() {
                // Try to use the actual final boss image first
                if (bossImages.finalBoss && bossImages.finalBoss.complete) {
                    try {
                        ctx.drawImage(bossImages.finalBoss, this.x, this.y, this.width, this.height);
                    } catch (e) {
                        this.drawFallback();
                    }
                } else {
                    this.drawFallback();
                }
                
                // Health bar
                const barWidth = this.width;
                const barHeight = 12;
                const healthPercent = this.hp / this.maxHp;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x, this.y - 25, barWidth, barHeight);
                ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.2 ? '#ffff00' : '#ff0000';
                ctx.fillRect(this.x, this.y - 25, barWidth * healthPercent, barHeight);
            }

            drawFallback() {
                ctx.fillStyle = '#8800ff';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(this.x + 30, this.y + 30, 100, 100);
                ctx.fillStyle = '#ffffff';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('FINAL', this.x + this.width/2, this.y + this.height/2 - 10);
                ctx.fillText('BOSS', this.x + this.width/2, this.y + this.height/2 + 20);
            }

            takeDamage() {
                this.hp--;
                return this.hp <= 0;
            }
        }

        // Explosion class
        class Explosion {
            constructor(x, y, size = 30) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.life = 20;
                this.maxLife = 20;
            }

            update() {
                this.life--;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                const currentSize = this.size * alpha;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentSize * 0.6, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // Initialize game objects
        const player = new Player();
        let boss = null;
        let finalBoss = null;

        // Input handling
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            
            if ((e.key === 'r' || e.key === 'R') && gameState === 'gameOver') {
                restartGame();
            }
        });

        function restartGame() {
            gameState = 'playing';
            score = 0;
            lives = 3;
            stage = 1;
            gameTime = 0;
            enemySpawnTimer = 0;
            bossActive = false;
            finalBossActive = false;
            
            bullets = [];
            enemies = [];
            explosions = [];
            particles = [];
            boss = null;
            finalBoss = null;
            
            player.x = canvas.width / 2 - 20;
            player.y = canvas.height - 60;
            
            updateUI();
            document.getElementById('gameOverText').style.display = 'none';
        }

        function spawnEnemy() {
            if (!bossActive && !finalBossActive && enemies.length < 6) {
                enemies.push(new Enemy(Math.random() * (canvas.width - 30), 0));
            }
        }

        function checkCollisions() {
            // Player bullets vs enemies
            bullets.forEach((bullet, bulletIndex) => {
                if (!bullet.friendly) return;
                
                enemies.forEach((enemy, enemyIndex) => {
                    if (bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {
                        
                        bullets.splice(bulletIndex, 1);
                        if (enemy.takeDamage()) {
                            enemies.splice(enemyIndex, 1);
                            explosions.push(new Explosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2));
                            score += 100;
                        }
                    }
                });
                
                // Player bullets vs boss
                if (boss && bullet.x < boss.x + boss.width &&
                    bullet.x + bullet.width > boss.x &&
                    bullet.y < boss.y + boss.height &&
                    bullet.y + bullet.height > boss.y) {
                    
                    bullets.splice(bulletIndex, 1);
                    if (boss.takeDamage()) {
                        explosions.push(new Explosion(boss.x + boss.width/2, boss.y + boss.height/2, 60));
                        boss = null;
                        bossActive = false;
                        score += 1000;
                        stage++;
                        
                        if (stage >= 3) {
                            finalBoss = new FinalBoss();
                            finalBossActive = true;
                        }
                    }
                }
                
                // Player bullets vs final boss
                if (finalBoss && bullet.x < finalBoss.x + finalBoss.width &&
                    bullet.x + bullet.width > finalBoss.x &&
                    bullet.y < finalBoss.y + finalBoss.height &&
                    bullet.y + bullet.height > finalBoss.y) {
                    
                    bullets.splice(bulletIndex, 1);
                    if (finalBoss.takeDamage()) {
                        explosions.push(new Explosion(finalBoss.x + finalBoss.width/2, finalBoss.y + finalBoss.height/2, 80));
                        finalBoss = null;
                        finalBossActive = false;
                        score += 2000;
                        // Victory!
                        console.log('🎉 Game Clear! You defeated all bosses!');
                    }
                }
            });
            
            // Enemy bullets vs player
            bullets.forEach((bullet, bulletIndex) => {
                if (bullet.friendly) return;
                
                if (bullet.x < player.x + player.width &&
                    bullet.x + bullet.width > player.x &&
                    bullet.y < player.y + player.height &&
                    bullet.y + bullet.height > player.y) {
                    
                    bullets.splice(bulletIndex, 1);
                    explosions.push(new Explosion(player.x + player.width/2, player.y + player.height/2));
                    lives--;
                    
                    if (lives <= 0) {
                        gameState = 'gameOver';
                    }
                }
            });
            
            // Enemies vs player
            enemies.forEach((enemy, enemyIndex) => {
                if (enemy.x < player.x + player.width &&
                    enemy.x + enemy.width > player.x &&
                    enemy.y < player.y + player.height &&
                    enemy.y + enemy.height > player.y) {
                    
                    enemies.splice(enemyIndex, 1);
                    explosions.push(new Explosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2));
                    lives--;
                    
                    if (lives <= 0) {
                        gameState = 'gameOver';
                    }
                }
            });
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('stage').textContent = stage;
        }

        function gameLoop() {
            if (gameState === 'playing') {
                gameTime++;
                
                // Spawn enemies after 2 seconds (120 frames at 60fps)
                if (gameTime >= 120) {
                    enemySpawnTimer++;
                    if (enemySpawnTimer >= 50) {  // Spawn every ~0.8 seconds
                        spawnEnemy();
                        enemySpawnTimer = 0;
                    }
                }
                
                // Spawn boss at score 500
                if (score >= 500 && !bossActive && !finalBossActive && !boss) {
                    boss = new Boss();
                    bossActive = true;
                    enemies = []; // Clear regular enemies
                    stage = 2;
                }
                
                // Update player
                player.update();
                
                // Update bullets
                bullets.forEach((bullet, index) => {
                    bullet.update();
                    if (bullet.isOffScreen()) {
                        bullets.splice(index, 1);
                    }
                });
                
                // Update enemies
                enemies.forEach(enemy => enemy.update());
                
                // Update boss
                if (boss) boss.update();
                if (finalBoss) finalBoss.update();
                
                // Update explosions
                explosions.forEach((explosion, index) => {
                    explosion.update();
                    if (explosion.isDead()) {
                        explosions.splice(index, 1);
                    }
                });
                
                // Check collisions
                checkCollisions();
                
                // Update UI
                updateUI();
            }
            
            // Clear canvas with starfield
            ctx.fillStyle = '#000011';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw moving stars
            for (let i = 0; i < 100; i++) {
                const x = (i * 7 + gameTime * 0.5) % canvas.width;
                const y = (i * 11) % canvas.height;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y, 1, 1);
            }
            
            if (gameState === 'playing') {
                // Draw game objects
                player.draw();
                
                bullets.forEach(bullet => bullet.draw());
                enemies.forEach(enemy => enemy.draw());
                explosions.forEach(explosion => explosion.draw());
                
                if (boss) boss.draw();
                if (finalBoss) finalBoss.draw();
                
            } else if (gameState === 'gameOver') {
                document.getElementById('gameOverText').style.display = 'block';
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize and start the game
        async function startGame() {
            console.log('🎮 シューティングゲーム開始！');
            await loadBossImages();
            gameLoop();
        }

        startGame();
    </script>
</body>
</html>